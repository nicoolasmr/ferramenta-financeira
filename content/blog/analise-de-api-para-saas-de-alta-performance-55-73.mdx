---
title: "Race Conditions: Como evitar saque duplo (Double Spend)"
excerpt: "Dois requests chegam ao mesmo tempo para sacar R$ 100. O saldo é R$ 100. Como garantir que o segundo falhe? Guia de Pessimistic Locking."
date: "2026-03-18T03:00:00.000Z"
category: "Tech & Engenharia"
tags: ["Concurrency", "Database", "Postgres", "Locking"]
readingTime: "10 min"
author: "RevenueOS Team"
---

# O Bug de R$ 1 Milhão

```javascript
// O jeito errado
const conta = await db.get(id);
if (conta.saldo >= 100) {
  await db.update(id, { saldo: conta.saldo - 100 });
}
```

Se dois requests executarem a linha 1 ao mesmo tempo, ambos verão saldo suficiente.
Ambos entrarão no `if`. Ambos sacarão.
O saldo ficará negativo (ou pior, sobrescrito errado). O dinheiro sumiu.

## SELECT ... FOR UPDATE

Para resolver isso, você precisa travar a linha no banco de dados até a transação terminar.
Isso se chama **Pessimistic Locking**.

```sql
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Ninguém mais pode ler ou escrever nesta linha até o commit
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

O segundo request vai ficar esperando (travado) até o primeiro terminar.

## Optimistic Locking (Para baixa concorrência)

Outra estratégia é usar versionamento.
`UPDATE accounts SET balance = 90, version = 2 WHERE id = 1 AND version = 1`

Se alguém mexeu na linha antes de você, a versão mudou. O update afeta 0 linhas. Você detecta isso e joga um erro para o usuário: "Dados mudaram, tente novamente".

## No RevenueOS

Nós usamos `FOR UPDATE` em todas as operações de saldo.
Isso garante integridade absoluta, mesmo que custe alguns milissegundos a mais de bloqueio.
Em finanças, **Corretude > Velocidade**.

<CTABox 
  title="Segurança de Dados" 
  subtitle="Durma tranquilo sabendo que o RevenueOS previne condições de corrida nativamente." 
  buttonText="Segurança do Core" 
  href="/security" 
/>
