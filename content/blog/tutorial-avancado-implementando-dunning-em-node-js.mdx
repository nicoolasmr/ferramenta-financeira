---
title: "Implementando Dunning em Node.js: Webhooks e Queues"
excerpt: "Tutorial mão na massa: Construindo um sistema de recuperação de falhas resiliente usando BullMQ, Stripe Webhooks e Node.js."
date: "2026-04-18T03:00:00.000Z"
category: "Tech & Engenharia"
tags: ["Node.js", "Dunning", "Webhooks", "Stripe"]
readingTime: "12 min"
author: "RevenueOS Team"
---

# Code-Level Dunning

Você vai construir um worker que escuta falhas de pagamento e age.

## 1. O Gatilho (Webhook)

```javascript
// route.ts
app.post('/webhooks', (req, res) => {
  const event = req.body;
  if (event.type === 'invoice.payment_failed') {
    await dunningQueue.add('handle-failure', {
      customerId: event.data.object.customer,
      attemptCount: event.data.object.attempt_count
    });
  }
  res.send(200);
});
```

## 2. O Processador (Worker)

O worker decide a lógica baseada na tentativa.

```javascript
// worker.ts
new Worker('DunningQueue', async job => {
  const { customerId, attemptCount } = job.data;
  const user = await db.getUser(customerId);

  if (attemptCount === 1) {
    await emailService.send(user.email, 'payment-failed-soft');
  } 
  else if (attemptCount === 3) {
    await emailService.send(user.email, 'payment-failed-hard');
    await subscriptionService.pause(user.id); // Degradação de serviço
  }
});
```

## 3. Dealing com "Card Updated"

Quando o usuário atualiza o cartão, você deve:
1.  Tentar cobrar as faturas atrasadas imediatamente (Retry).
2.  Se funcionar, restaurar o serviço (`subscriptionService.resume`).
3.  Cancelar os jobs de dunning futuros na fila.

O RevenueOS abstrai toda essa máquina de estados complexa pra você.

<CTABox 
  title="Não code isso do zero" 
  subtitle="Use a API de Dunning do RevenueOS e economize 3 meses de desenvolvimento." 
  buttonText="API Docs" 
  href="/docs/dunning" 
/>
