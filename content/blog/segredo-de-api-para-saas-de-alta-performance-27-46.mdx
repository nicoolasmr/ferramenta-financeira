---
title: "Filas e Workers: Orquestrando Background Jobs"
excerpt: "Como processar milhares de boletos sem travar o servidor. Um guia sobre SQS, RabbitMQ e BullMQ."
date: "2026-03-23T03:00:00.000Z"
category: "Tech & Engenharia"
tags: ["Queues", "Background Jobs", "Performance", "Arquitetura"]
readingTime: "9 min"
author: "RevenueOS Team"
---

# Async First

Para cada ação do usuário, pergunte: "Eu preciso responder agora?".
*   Login? Sim.
*   Criar Cobrança no Stripe? Sim.
*   Enviar E-mail de Boas Vindas? **Não.**
*   Gerar PDF da Nota Fiscal? **Não.**

Tudo que não é crítico para a resposta HTTP imediata deve ir para uma **Fila**.

## Anatomia de um Job

```json
{
  "job": "send_email",
  "payload": { "user_id": 123, "template": "welcome" },
  "attempts": 0,
  "max_attempts": 3
}
```

O Worker pega esse job, processa e marca como `Completed`.
Se falhar, incrementa `attempts` e devolve para a fila (com um delay).

## Dead Letter Queues (DLQ)

E se falhar 3 vezes? O job morre?
Não. Ele vai para a DLQ (Fila de Cartas Mortas).
Um engenheiro deve monitorar a DLQ diariamente. É lá que os bugs reais aparecem.
*"Olha, o e-mail falhou porque o usuário digitou `.com.br` errado."*

## BullMQ vs SQS

*   **BullMQ (Redis):** Ótimo para Node.js, rápido, barato. Mas se o Redis encher, pode perder jobs se não configurado com persistência AOF.
*   **AWS SQS:** Infinito, robusto, "set and forget". Mas tem latência maior e custo por request.

No RevenueOS, usamos SQS para coisas críticas (Dinheiro) e BullMQ para coisas voláteis (Notificações).

<CTABox 
  title="Processamento Assíncrono" 
  subtitle="Descubra como nossa arquitetura de eventos garante que nenhuma tarefa se perca no limbo." 
  buttonText="Arquitetura" 
  href="/features/infrastructure" 
/>
