---
title: "Idempotência em APIs de Pagamento: O Guia Definitivo"
excerpt: "Por que cobrar o cliente duas vezes é o maior pecado de um dev e como usar chaves de idempotência para evitar duplicidade em redes instáveis."
date: "2026-03-06T03:00:00.000Z"
category: "API & Integrações"
tags: ["Idempotência", "API", "Backend", "Pagamentos"]
readingTime: "11 min"
author: "RevenueOS Team"
---

# Idempotência: Como não cobrar R$ 10.000 duas vezes por acidente

Você envia um POST `/v1/charges` para cobrar o cartão do cliente.
A internet pisca. O request sai, mas o response não volta.
O que aconteceu?
1.  O servidor nunca recebeu?
2.  O servidor recebeu, cobrou, mas a resposta se perdeu?

Se você tentar de novo (retry) no cenário 2, você acabou de cobrar o cartão duas vezes. Parabéns, você gerou um chargeback e frustrou um cliente.

Para resolver isso, existe um conceito matemático chamado **Idempotência**.

**O que você vai aprender:**
*   Como implementar `Idempotency-Key` no header.
*   A diferença entre "Safe Methods" (GET) e "Unsafe" (POST).
*   Como o Stripe e o RevenueOS lidam com retries automáticos.

## O que é Idempotência?
Na matemática, `f(x) = f(f(x))`.
Na API, fazer o mesmo request 10 vezes deve ter o mesmo efeito colateral de fazer apenas 1 vez.

## Como Implementar

O cliente (seu frontend ou backend) deve gerar um UUID único antes do request:

```bash
POST /api/charges
Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000
Body: { amount: 1000 }
```

Seu servidor salva esse UUID no Redis ou Postgres com um TTL de 24h.
1.  Chegou request.
2.  Existe a chave `550e...-440000`?
    *   **Sim:** Retorne a resposta salva (Cached Response). NÁO COBRE NOVAMENTE.
    *   **Não:** Execute a cobrança, salve a resposta e retorne.

## Erros Comuns

### 1. Usar dados do body como chave
Não faça hash do payload. Se o usuário clicar "Pagar" duas vezes intencionalmente, são duas cobranças distintas. A chave deve ser gerada por "Intenção de Clique".

### 2. Condição de Corrida (Race Condition)
Se dois requests com a mesma chave chegarem no mesmo milissegundo, você precisa de um **Lock Atômico** no banco de dados.
`INSERT INTO idempotency_keys ... ON CONFLICT DO NOTHING`.

## O RevenueOS cuida disso?
Sim. Nossa API é 100% idempotente.
Se você usar nossa SDK, nós geramos as chaves automaticamente e fazemos retries com exponential backoff. Você nunca precisa se preocupar com dupla cobrança.

<CTABox 
  title="API à prova de falhas" 
  subtitle="Use a infraestrutura do RevenueOS e ganhe resiliência de rede de graça." 
  buttonText="Ler Documentação" 
  href="/docs/api" 
/>
